{"componentChunkName":"component---src-templates-post-tsx","path":"/jvm-basics/","result":{"data":{"markdownRemark":{"html":"<p> JVM(Java Virtual Machine)은 피지컬 머신에서 자바 코드를 컴파일하고 실행한다.\n초기의 JVM은 Java 플랫폼만을 지원하도록 설계 되었지만, 현재는 Kotlin, Groovy, Scala와 같은 다양한 언어를 지원하고 있다. 이렇게 JVM이 지원하는 언어들을 통틀어 JVM languages라고도 한다.</p>\n<h1 id=\"jvm-java-virtual-machine\" style=\"position:relative;\"><a href=\"#jvm-java-virtual-machine\" aria-label=\"jvm java virtual machine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JVM (Java Virtual Machine)</h1>\n<p> JVM이라는 이름에서 알 수 있 듯, JVM을 <code class=\"language-text\">가상 머신(Virtual Machine)</code>이라 부른다. 그렇다면 가상머신이란 무엇일까?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/660790ca357f02a7c04bf2fd243b9c4d/8c52a/jvm-structure.006.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.27027027027026%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB21AiP//EABYQAQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQLEV//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAARECExQbH/2gAIAQEAAT8hVC6I1DM//9oADAMBAAIAAwAAABADz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAAEEAwEAAAAAAAAAAAAAAAEAESExQVFhkf/aAAgBAQABPxA2cGFcCbY4jAQ8adBmwK0snHsprarS/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VM Components Image\"\n        title=\"VM Components Image\"\n        src=\"/static/660790ca357f02a7c04bf2fd243b9c4d/1c72d/jvm-structure.006.jpg\"\n        srcset=\"/static/660790ca357f02a7c04bf2fd243b9c4d/a80bd/jvm-structure.006.jpg 148w,\n/static/660790ca357f02a7c04bf2fd243b9c4d/1c91a/jvm-structure.006.jpg 295w,\n/static/660790ca357f02a7c04bf2fd243b9c4d/1c72d/jvm-structure.006.jpg 590w,\n/static/660790ca357f02a7c04bf2fd243b9c4d/a8a14/jvm-structure.006.jpg 885w,\n/static/660790ca357f02a7c04bf2fd243b9c4d/fbd2c/jvm-structure.006.jpg 1180w,\n/static/660790ca357f02a7c04bf2fd243b9c4d/8c52a/jvm-structure.006.jpg 2220w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p> 가상머신은 하나의 물리적인 하드웨어 위에서 격리되어 구동되는 가상 환경이라 할 수 있다. 가상머신은 하이퍼바이저라는 소프트웨어가 설치된 하나의 호스트 머신 위에서 각각 CPU, 메모리, 스토리지, 네트워크 인터페이스를 갖추고 있다. 이러한 <code class=\"language-text\">System Virtual Machine</code>은 서로 격리된 환경에서 OS가 제공하는 대부분의 기능들을 제공한다.</p>\n<p> JVM은 OS로부터 메모리 공간을 할당 받아 해당 메모리를 자체적으로 관리하며, 독립적인 런타임 환경에서 Java 클래스 파일을 실행하는 <code class=\"language-text\">Process Virtual Machine</code>이다.</p>\n<br/>\n<hr>\n<h1 id=\"jvm의-구성요소\" style=\"position:relative;\"><a href=\"#jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\" aria-label=\"jvm의 구성요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JVM의 구성요소</h1>\n<p> 컴파일 이후 JVM이 Java Application을 실행하는 큰 흐름은 다음과 같다.</p>\n<blockquote>\n<p>(1) 컴파일 된 class 파일을 <code class=\"language-text\">Class Loader</code>가 <code class=\"language-text\">Runtime Data Area</code>에 로드한다. <br>\n(2) 적재한 바이트코드를 <code class=\"language-text\">Execution Engine</code>이 실행한다. <br>\n(3) 실행 도 중 Heap 영역에서 더 이상 참조되지 않는 objects 들을 <code class=\"language-text\">Garbage Collector</code> 가 정리한다.</p>\n</blockquote>\n<p> 생략된 것이 많은 내용이지만 애플리케이션이 실행된 이후 종료되기까지, <br>\n<code class=\"language-text\">Class Loader</code>, <code class=\"language-text\">Runtime Data Area</code>, <code class=\"language-text\">Execution Engine</code>, <code class=\"language-text\">Garbage Collector</code> 와 같은 JVM 주요 컴포넌트들이 이런 유기적인 상호작용을 하며 동작한다. (<code class=\"language-text\">Garbage Collector</code>는 실행엔진 영역의 컴포넌트이지만, 중요도가 높아서 별도로 표기하였다.)</p>\n<p> JVM의 핵심 컴포넌트들은 다음과 같은 구조를 이룬다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f0a9e098dcf789ce55ab5c2f10de7626/bddf7/jvm-structure.001.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFAf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAW1cYKZBD//EABsQAQACAgMAAAAAAAAAAAAAAAIBAwASBBET/9oACAEBAAEFAuQylHmZC3Gy62WW2WRb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAIRAAAQMCBwEAAAAAAAAAAAAAAgABEQMxEhMhIjJhkqH/2gAIAQEABj8CwkEx2yZ8v6KYrSuRelR3Pq6KKhXX/8QAGxABAAIDAQEAAAAAAAAAAAAAAQARIVFhMUH/2gAIAQEAAT8hsF28OxhVZVSxhwhU1n1EyudHPuYdjB0DP//aAAwDAQACAAMAAAAQYw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAAMAAwEAAAAAAAAAAAABEQAhMUFhcYH/2gAIAQEAAT8Qbm0hHVC65+5Uv2oSNPf3BpYWkZ+msa6yrfK984EmOtSTFdusHYwBAvDWf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JVM Structure Image\"\n        title=\"JVM Structure Image\"\n        src=\"/static/f0a9e098dcf789ce55ab5c2f10de7626/1c72d/jvm-structure.001.jpg\"\n        srcset=\"/static/f0a9e098dcf789ce55ab5c2f10de7626/a80bd/jvm-structure.001.jpg 148w,\n/static/f0a9e098dcf789ce55ab5c2f10de7626/1c91a/jvm-structure.001.jpg 295w,\n/static/f0a9e098dcf789ce55ab5c2f10de7626/1c72d/jvm-structure.001.jpg 590w,\n/static/f0a9e098dcf789ce55ab5c2f10de7626/a8a14/jvm-structure.001.jpg 885w,\n/static/f0a9e098dcf789ce55ab5c2f10de7626/fbd2c/jvm-structure.001.jpg 1180w,\n/static/f0a9e098dcf789ce55ab5c2f10de7626/bddf7/jvm-structure.001.jpg 3268w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p> JVM을 구성하는 핵심 컴포넌트들을 정확하게 이해하는 것이 곧 JVM을 이해하는 것이라 할 수 있다. <br>\n이제부터 각 컴포넌트들을 하나씩 살펴보자.</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"class-loader\" style=\"position:relative;\"><a href=\"#class-loader\" aria-label=\"class loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Loader</h2>\n<p> 클래스 로더는 컴파일 된 바이트 코드(<code class=\"language-text\">.class</code> files)들을 <code class=\"language-text\">Runtime Data Area</code> 에 로드한다. <br>\n여기서 주의해야 할 것은, 모든 클래스 파일들을 이 시점에 로드하는 것이 아니라는 점이다. JVM의 기본 클래스 로딩 방식은 Lazy loading이다. <code class=\"language-text\">main()</code> 메소드가 위치한 클래스를 로드하고, 실행엔진으로 바이트 코드를 해석하며, 필요할 때 마다 각 클래스를 메인 메모리에 적재하고 읽어들인다.</p>\n<p> 클래스 로더의 세부 구성을 살펴보면 다음과 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/99e3a103b82f663837766a2da6f982b8/5be49/jvm-structure.002.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.1891891891892%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHabZWSD//EABcQAQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQEAAQUC5WMV/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAEhMRBx/9oACAEBAAE/IU/BQa6Kd4Wn/9oADAMBAAIAAwAAABDTD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQACAgIDAAAAAAAAAAAAAAEAESExQVFhocH/2gAIAQEAAT8QWjsdeIRJoV4hAwcbqYGWvkKN36lxb46n/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Class Loader Image\"\n        title=\"Class Loader Image\"\n        src=\"/static/99e3a103b82f663837766a2da6f982b8/1c72d/jvm-structure.002.jpg\"\n        srcset=\"/static/99e3a103b82f663837766a2da6f982b8/a80bd/jvm-structure.002.jpg 148w,\n/static/99e3a103b82f663837766a2da6f982b8/1c91a/jvm-structure.002.jpg 295w,\n/static/99e3a103b82f663837766a2da6f982b8/1c72d/jvm-structure.002.jpg 590w,\n/static/99e3a103b82f663837766a2da6f982b8/a8a14/jvm-structure.002.jpg 885w,\n/static/99e3a103b82f663837766a2da6f982b8/fbd2c/jvm-structure.002.jpg 1180w,\n/static/99e3a103b82f663837766a2da6f982b8/5be49/jvm-structure.002.jpg 2578w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p> 클래스 로더의 동작 메커니즘은 크게 <code class=\"language-text\">Loading</code>, <code class=\"language-text\">Linking</code>, <code class=\"language-text\">Initialization</code>  세 단계의 절차로 수행된다. <br>\n각 과정들을 하나씩 살펴보자.</p>\n<br/>\n<h3 id=\"loading\" style=\"position:relative;\"><a href=\"#loading\" aria-label=\"loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Loading</h3>\n<p> 클래스 로더가 바이트 코드를 JVM에 로드하는 과정이다.<code class=\"language-text\">java.lang</code>, <code class=\"language-text\">java.util</code> 같은 Java의 스탠다드 패키지부터 라이브러리까지 각 바이트 코드마다 담당하는 클래스 로더가 다르다. 내부적으로 JVM이 <code class=\"language-text\">ClassLoader.loadClass()</code> 를 실행하여 메모리에 바이트 코드를 적재한다. </p>\n<p> Class Loader의 세부적인 계층 구성은 다음과 같다. </p>\n<ul>\n<li><strong>Boostrap Class Loader</strong> : 모든 클래스 로더의 루트 레벨로써, <code class=\"language-text\">rt.jar</code>  파일에 위치하는 Java의 스탠다드 패키지들과 <code class=\"language-text\">$JAVA_HOME/jre/lib</code> 에 있는 코어 라이브러리들을 로드한다.</li>\n<li><strong>Extention Class Loader :</strong> <code class=\"language-text\">$JAVA_HOME/jre/lib/ext</code> 에 위치하는 extension Java 라이브러리들을 로드한다.</li>\n<li><strong>Application Class Loader</strong> : <code class=\"language-text\">classpath</code> 에 위치한 클래스들을 찾아서 로드한다. 즉, 라이브러리가 아닌 개발자가 작성한 소스파일로부터 생성된 바이트 코드들을 JVM에 적재한다.</li>\n</ul>\n<p> 클래스 로더는 상위 로더부터 클래스를 하나씩 찾아간다. 최하단에 있는 클래스 로더까지 해당되는 클래스 파일을 찾지 못하면 <code class=\"language-text\">ClassNotFoundException</code> 예외가 발생한다. </p>\n<br/>\n<h3 id=\"linking\" style=\"position:relative;\"><a href=\"#linking\" aria-label=\"linking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linking</h3>\n<p> <code class=\"language-text\">Linking</code>은 클래스 파일이 메모리에 적재 된 이후 의존하는 클래스 파일들을 서로 연결(Link)하고 검증하는 과정이다.</p>\n<ul>\n<li><strong>Verification</strong> : 클래스 파일의 유효성을 검증한다. 유효하지 않은 클래스 파일인 경우 <code class=\"language-text\">VerifyException</code> 이 발생한다.</li>\n<li><strong>Preparation</strong> : 유효성 검증을 통과한 클래스 파일들에 대하여 static 필드 및 클래스를 기본 값과 함께 초기화한다.</li>\n<li><strong>Resolution</strong> : Symbolic Reference 값들을 클래스, 상수, 메소드 등 Runtime Constant Pool에 있는 실제 메모리 참조 값(Actual Reference)으로 대체한다.</li>\n</ul>\n<br/>\n<h3 id=\"initialization\" style=\"position:relative;\"><a href=\"#initialization\" aria-label=\"initialization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Initialization</strong></h3>\n<p> constructor, static block 실행 등 초기화 과정이 수행된다. 클래스 로딩의 마지막 과정이라 할 수 있다. JVM은 멀티 쓰레드 환경에서 구동되기 때문에 Initialization 과정에서도 동시성 이슈가 발생할 여지가 있으므로 주의 해야한다.</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"runtime-data-area\" style=\"position:relative;\"><a href=\"#runtime-data-area\" aria-label=\"runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Runtime Data Area</h2>\n<p> 앞서 살펴본 것과 같이 클래스 파일들은 Class Loader에 의해 Runtime Data Area에 적재 된다. Runtime Data Area는 5개 영역으로 나뉘어져 있는데, 애플리케이션 실행 도 중 데이터의 타입에 따라 <code class=\"language-text\">Method Area</code>, <code class=\"language-text\">Heap Area</code>, <code class=\"language-text\">Stack Area</code>, <code class=\"language-text\">PC Register</code>, <code class=\"language-text\">Native Method Stack</code> 영역에 저장되고 참조된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9d747902838a3e7712df8ecd92794bf/e4f26/jvm-structure.003.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAbsneDxIf//EABkQAAMAAwAAAAAAAAAAAAAAAAABEQIEEP/aAAgBAQABBQIWzlylZT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAMgIRIP/aAAgBAQAGPwIWLVn/xAAcEAACAgIDAAAAAAAAAAAAAAAAARFRECFBYcH/2gAIAQEAAT8hXhp8mGVs7GStn//aAAwDAQACAAMAAAAQow//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAwEAAwAAAAAAAAAAAAABEQAhMVFx4fH/2gAIAQEAAT8QsqMKICwnnd2Gji8wJHLs+lB7af/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Runtime Data Area Image\"\n        title=\"Runtime Data Area Image\"\n        src=\"/static/c9d747902838a3e7712df8ecd92794bf/1c72d/jvm-structure.003.jpg\"\n        srcset=\"/static/c9d747902838a3e7712df8ecd92794bf/a80bd/jvm-structure.003.jpg 148w,\n/static/c9d747902838a3e7712df8ecd92794bf/1c91a/jvm-structure.003.jpg 295w,\n/static/c9d747902838a3e7712df8ecd92794bf/1c72d/jvm-structure.003.jpg 590w,\n/static/c9d747902838a3e7712df8ecd92794bf/a8a14/jvm-structure.003.jpg 885w,\n/static/c9d747902838a3e7712df8ecd92794bf/fbd2c/jvm-structure.003.jpg 1180w,\n/static/c9d747902838a3e7712df8ecd92794bf/e4f26/jvm-structure.003.jpg 3382w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<br/>\n<h3 id=\"method-area\" style=\"position:relative;\"><a href=\"#method-area\" aria-label=\"method area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method Area</h3>\n<p> 실행 시점에 사용되는 Constant Pool, field, method, constructors 같은 데이터들이 위치한다. 만약 가용 공간이 부족하다면 <code class=\"language-text\">OutOfMemorryError</code> 가 발생한다. JVM 당 하나의 <code class=\"language-text\">Method Area</code> 를 가진다.</p>\n<br/>\n<h3 id=\"heap-area\" style=\"position:relative;\"><a href=\"#heap-area\" aria-label=\"heap area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heap Area</h3>\n<p> 객체 및 인스턴스 변수, 배열 등과 같은 타입의 값들이 위치한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Example</span> example <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p> 예를 들어 위와 같은 코드를 동작 시키면 <code class=\"language-text\">Example</code> 인스턴스를 생성한 뒤 Heap Area에 배치한다. 메소드 영역과 마찬가지로 힙 영역 역시 JVM 당 하나의 공간만을 갖게 된다.</p>\n<br/>\n<h3 id=\"stack-area\" style=\"position:relative;\"><a href=\"#stack-area\" aria-label=\"stack area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack Area</h3>\n<p> 특정 메소드가 호출 되고 실행되면서 사용되는 지역 변수(Local Variables), 중간 연산 결과(Operand Stack) 값이 갱신되며 저장되는 영역이다. 메소드 호출 시점마다 <code class=\"language-text\">Stack Frame</code>이라는 하나의 단위가 스택에 생성되고, 해당 메소드가 종료되는 시점에 파괴된다.</p>\n<p> 스택 영역은 JVM에 의해 쓰레드가 생성될 때 마다 각 쓰레드에 하나씩 할당된다. 따라서 동시성 문제로부터 자유롭다.</p>\n<br/>\n<h3 id=\"program-counter-pc-registers\" style=\"position:relative;\"><a href=\"#program-counter-pc-registers\" aria-label=\"program counter pc registers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Program Counter (PC) Registers</h3>\n<p> 현재 실행되고 있는 명령어의 주소 값이 저장되는 공간이다. PC Register는 현재 실행하고 있는 명령어의 실행이 끝나면 다음 명령어의 주소 값을 갱신한다. 각 쓰레드 마다 하나의 PC Register가 할당된다.</p>\n<br/>\n<h3 id=\"native-method-stacks\" style=\"position:relative;\"><a href=\"#native-method-stacks\" aria-label=\"native method stacks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Native Method Stacks</h3>\n<p> Java가 아닌 C, C++과 같은 언어로 작성 된 메소드(Native Method) 실행을 지원하는 영역. 스택 영역과 같이 각 쓰레드마다 하나의 공간이 할당된다.</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"execution-engine\" style=\"position:relative;\"><a href=\"#execution-engine\" aria-label=\"execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Execution Engine</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7bf4997581a6b631f5b568a4b80bee6d/5f17e/jvm-structure.004.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.72972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAMEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAc6QKYP/xAAaEAACAgMAAAAAAAAAAAAAAAABBAITAxES/9oACAEBAAEFAgV6zJXeavr/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAdEAABAgcAAAAAAAAAAAAAAAABAAIDERIhIiNh/9oACAEBAAY/ArtfWhhEktQIHV//xAAaEAACAwEBAAAAAAAAAAAAAAABIQARMUHh/9oACAEBAAE/IacJGbVxG0W/YRZbhdn/2gAMAwEAAgADAAAAEIPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAQACAwEAAAAAAAAAAAAAAREAITFBYXH/2gAIAQEAAT8QC5xiarffGMWYxTUmp9YPYfanle3zP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Execution Engine Image\"\n        title=\"Execution Engine Image\"\n        src=\"/static/7bf4997581a6b631f5b568a4b80bee6d/1c72d/jvm-structure.004.jpg\"\n        srcset=\"/static/7bf4997581a6b631f5b568a4b80bee6d/a80bd/jvm-structure.004.jpg 148w,\n/static/7bf4997581a6b631f5b568a4b80bee6d/1c91a/jvm-structure.004.jpg 295w,\n/static/7bf4997581a6b631f5b568a4b80bee6d/1c72d/jvm-structure.004.jpg 590w,\n/static/7bf4997581a6b631f5b568a4b80bee6d/a8a14/jvm-structure.004.jpg 885w,\n/static/7bf4997581a6b631f5b568a4b80bee6d/fbd2c/jvm-structure.004.jpg 1180w,\n/static/7bf4997581a6b631f5b568a4b80bee6d/5f17e/jvm-structure.004.jpg 2532w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p> Runtime Data Area에 각 바이트코드가 로드되면 <code class=\"language-text\">Execution Engine</code>이 이들을 실행하는데, Java compiler에 의해 생성된 클래스 파일들은 머신이 읽을 수 있는 기계어가 아닌 바이트 코드이다. 따라서 이를 한번 더 변환하는 과정이 필요하다.</p>\n<p> JVM은 효율성을 위해 두 가지 방법을 혼합하여 이를 실현한다. 기본 전략으로는 JavaScript, Python와 같은 언어 처럼 <code class=\"language-text\">Interpreter</code>가 한 라인씩 바이트 코드를 해석하는 방식을 사용하고, 만약 반복되는 바이트 코드가 발견되면 <code class=\"language-text\">JIT Compiler</code> 를 통해 이들을 한번에 변환하기도 한다.</p>\n<br/>\n<h3 id=\"interpreter\" style=\"position:relative;\"><a href=\"#interpreter\" aria-label=\"interpreter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interpreter</h3>\n<p> 바이트 코드를 한 줄씩 읽고 실행한다. 매 라인마다 이러한 동작을 반복하기 때문에, 코드 구성에 따라 통으로 컴파일하는 방식 보다 느릴 수 있다.</p>\n<p>   아래처럼 값을 누적하는 코드와 같이, 같은 메소드의 반복이 자주 등장하는 코드의 경우 이를 통으로 변환하는 것이 더 유리할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> total <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   total <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<h3 id=\"jit-compiler\" style=\"position:relative;\"><a href=\"#jit-compiler\" aria-label=\"jit compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JIT Compiler</h3>\n<p> 앞서 설명한 것과 같이, 반복되는 코드가 빈번한 경우, 인터프리터 방식이 성능상 비효율적일 수 있다. 실행 엔진은 <code class=\"language-text\">JIT Compiler</code> 를 통해 이를 해결한다.\nJIT Compiler의 구성요소인 <code class=\"language-text\">Profiler</code>를 통해 반복되는 코드(hotspot)를 발견하면 JIT Compiler는 이를 네이티브 머신 코드로 한번에 컴파일한다. 변환된 코드는 시스템에 의해 한번에 읽히게 되므로 성능이 향상된다.</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"garbage-collector\" style=\"position:relative;\"><a href=\"#garbage-collector\" aria-label=\"garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collector</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/661992c534819b6bf63cbbf65144f476/1589e/jvm-structure.005.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26.351351351351354%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAFABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHSgC4if//EABgQAAMBAQAAAAAAAAAAAAAAAAACEgED/9oACAEBAAEFAoYzmxLH/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAIRIjH/2gAIAQMBAT8Be2kH/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAECEiH/2gAIAQIBAT8BjiZVH//EABcQAAMBAAAAAAAAAAAAAAAAAAABMjP/2gAIAQEABj8C0ZbLZ//EABkQAAIDAQAAAAAAAAAAAAAAAAERABAhMf/aAAgBAQABPyF+QEL5UH//2gAMAwEAAgADAAAAEPfv/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAERsdH/2gAIAQMBAT8QSk+MJP/EABgRAAMBAQAAAAAAAAAAAAAAAAABEUHw/9oACAECAQE/EEiWnFZ//8QAHRABAAEDBQAAAAAAAAAAAAAAAQARMdEhQYGRof/aAAgBAQABPxBYum6WcxGOJf2CbfeZ/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Garbage Collector Image\"\n        title=\"Garbage Collector Image\"\n        src=\"/static/661992c534819b6bf63cbbf65144f476/1c72d/jvm-structure.005.jpg\"\n        srcset=\"/static/661992c534819b6bf63cbbf65144f476/a80bd/jvm-structure.005.jpg 148w,\n/static/661992c534819b6bf63cbbf65144f476/1c91a/jvm-structure.005.jpg 295w,\n/static/661992c534819b6bf63cbbf65144f476/1c72d/jvm-structure.005.jpg 590w,\n/static/661992c534819b6bf63cbbf65144f476/a8a14/jvm-structure.005.jpg 885w,\n/static/661992c534819b6bf63cbbf65144f476/fbd2c/jvm-structure.005.jpg 1180w,\n/static/661992c534819b6bf63cbbf65144f476/1589e/jvm-structure.005.jpg 2530w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p> <code class=\"language-text\">Garbage Collector</code> 는 Heap Area에 로드 되었지만 현재는 참조 되고 있지 않는 오브젝트들을 찾아서 지우고 사용되지 않는 메모리 공간을 다시 회수한다.</p>\n<p>   이는 다음의 두 과정을 거친다.</p>\n<ol>\n<li><strong>Mark</strong> : GC가 참조되지 않는 오브젝트들을 찾아서 mark한다.</li>\n<li><strong>Sweep</strong> : GC가 mark 된 오브젝트들을 힙 메모리로부터 정리한다.</li>\n</ol>\n<p>GC는 JVM에 의해 텀을 두고 자동으로 동작한다. <code class=\"language-text\">System.gc()</code> 를 통해 명시적으로 호출하는 방법도 있지만 이는 즉시 동작을 보장하진 않는다. 또한 JVM은 GC를 수행할 때, 이를 실행하는 쓰레드 이외에는 작업을 중단(<code class=\"language-text\">Stop The World</code>)하게 되므로 명시적인 호출은 지양해야 한다.</p>\n<p>(GC는 그 자체로 다루어야 할 주제가 굉장히 많다고 생각한다. 추후 별도의 학습 포스트로 다뤄 볼 예정이므로, 이번 포스트에서는\n대표적인 몇 가지 GC만 가볍게 살펴보고 넘어가려 한다.)</p>\n<br/>\n<h3 id=\"serial-gc\" style=\"position:relative;\"><a href=\"#serial-gc\" aria-label=\"serial gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Serial GC</h3>\n<p> 싱글 쓰레드 환경의 작은 애플리케이션에서 동작하는 가장 단순한 방식의 GC 구현체이다. 싱글 쓰레드 환경에만 적합한 GC이기 때문에 GC가 동작할 때 애플리케이션 전체가 중지(<code class=\"language-text\">Stop The World</code>) 된다.</p>\n<br/>\n<h3 id=\"parallel-gc\" style=\"position:relative;\"><a href=\"#parallel-gc\" aria-label=\"parallel gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel GC</h3>\n<p> JVM의 Java 8의 default GC 구현체이며, 다중 쓰레드 환경을 지원한다. <code class=\"language-text\">Serial GC</code> 보다 빠른 퍼포먼스를 보여준다.</p>\n<br/>\n<h3 id=\"garbage-first-gc-g1-gc\" style=\"position:relative;\"><a href=\"#garbage-first-gc-g1-gc\" aria-label=\"garbage first gc g1 gc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage First GC (G1 GC)</h3>\n<p> 멀티 프로세스 환경을 지원하기 위해 개발 된 GC 구현체이며, 대용량 메모리 운용이 가능하다. <code class=\"language-text\">Stop The World</code> 시간을 최소화 하였지만, 이를 완전 해결하지는 못했다. Java 9부터 default GC 구현체이다.</p>\n<br/>\n<hr>\n<br/>\n<h2 id=\"java-native-interface-jni\" style=\"position:relative;\"><a href=\"#java-native-interface-jni\" aria-label=\"java native interface jni permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java Native Interface (JNI)</h2>\n<p> 앞서 <code class=\"language-text\">Runtime Data Area</code>의 <code class=\"language-text\">Native Method Stacks</code>를 다루며 <code class=\"language-text\">Native Code</code>에 대해 간단히 언급했었다.\nJNI 역시 Java가 아닌 네이티브 코드를 사용하여 OS 혹은 하드웨어를 컨트롤하는 소프트웨어 또는 라이브러리의 사용을 가능하게 한다.</p>\n<br/>\n<hr>\n<br/>\n<br/>\n<br/>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References:</h3>\n<p><a href=\"https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html</a>\n<a href=\"https://en.wikipedia.org/wiki/Java_virtual_machine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://en.wikipedia.org/wiki/Java<em>virtual</em>machine</a>\n<a href=\"https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/</a>\n<a href=\"https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor</a>\n<a href=\"https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine</a></p>","excerpt":"JVM(Java Virtual Machine)은 피지컬 머신에서 자바 코드를 컴파일하고 실행한다.\n초기의 JVM은 Java 플랫폼만을 지원하도록 설계 되었지만, 현재는 Kotlin, Groovy, Scala와 같은 다양한 언어를 지원하고 있다. 이렇…","tableOfContents":"<ul>\n<li><a href=\"/jvm-basics/#jvm-java-virtual-machine\">JVM (Java Virtual Machine)</a></li>\n<li>\n<p><a href=\"/jvm-basics/#jvm%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C\">JVM의 구성요소</a></p>\n<ul>\n<li>\n<p><a href=\"/jvm-basics/#class-loader\">Class Loader</a></p>\n<ul>\n<li><a href=\"/jvm-basics/#loading\">Loading</a></li>\n<li><a href=\"/jvm-basics/#linking\">Linking</a></li>\n<li><a href=\"/jvm-basics/#initialization\"><strong>Initialization</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/jvm-basics/#runtime-data-area\">Runtime Data Area</a></p>\n<ul>\n<li><a href=\"/jvm-basics/#method-area\">Method Area</a></li>\n<li><a href=\"/jvm-basics/#heap-area\">Heap Area</a></li>\n<li><a href=\"/jvm-basics/#stack-area\">Stack Area</a></li>\n<li><a href=\"/jvm-basics/#program-counter-pc-registers\">Program Counter (PC) Registers</a></li>\n<li><a href=\"/jvm-basics/#native-method-stacks\">Native Method Stacks</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/jvm-basics/#execution-engine\">Execution Engine</a></p>\n<ul>\n<li><a href=\"/jvm-basics/#interpreter\">Interpreter</a></li>\n<li><a href=\"/jvm-basics/#jit-compiler\">JIT Compiler</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/jvm-basics/#garbage-collector\">Garbage Collector</a></p>\n<ul>\n<li><a href=\"/jvm-basics/#serial-gc\">Serial GC</a></li>\n<li><a href=\"/jvm-basics/#parallel-gc\">Parallel GC</a></li>\n<li><a href=\"/jvm-basics/#garbage-first-gc-g1-gc\">Garbage First GC (G1 GC)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/jvm-basics/#java-native-interface-jni\">Java Native Interface (JNI)</a></p>\n<ul>\n<li><a href=\"/jvm-basics/#references\">References:</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/jvm-basics/"},"frontmatter":{"title":"JVM의 구조","date":"Apr 10, 2022","tags":["JVM","GC"],"keywords":["JVM","JVM Architecture","Class Loader","Runtime Data Area","Execution Engine","Garbage Collector","GC"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/jvm-basics/","series":[],"lastmod":"2022-04-10"}},"staticQueryHashes":["2027115977","694178885"]}
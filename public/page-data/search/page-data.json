{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n&ensp;JVM(Java Virtual Machine)은 피지컬 머신에서 자바 코드를 컴파일하고 실행하기 위한 필수 요소라 할 수 있다.\n초기의 JVM은 Java 플랫폼만을 지원하도록 설계 되었지만, 현재는 Kotlin, Groovy, Scala와 같은 다양한 언어를 지원하고 있다. 이렇게 JVM이 지원하는 언어들을 통틀어 JVM languages라고도 한다.\n\n\n# JVM (Java Virtual Machine)\n\n&ensp;JVM이라는 이름에서 알 수 있 듯, JVM을 `가상 머신(Virtual Machine)`이라 부른다. 그렇다면 가상머신이란 무엇일까?\n\n![VM Components Image](./jvm-structure.006.jpeg)\n\n&ensp;가상머신은 하나의 물리적인 하드웨어 위에서 격리되어 구동되는 가상 환경이라 할 수 있다. 하나의 가상머신은 하이퍼바이저라는 소프트웨어가 설치된 하나의 호스트 머신 위에서 각각 CPU, 메모리, 스토리지, 네트워크 인터페이스를 갖추고 있다. 이러한 `System Virtual Machine`은 각각 격리된 환경에서 OS가 제공하는 대부분의 기능들을 제공한다.\n\n&ensp;JVM은 OS로부터 메모리 공간을 할당 받아 해당 메모리를 자체적으로 관리하며, 독립적인 런타임 환경에서 Java 클래스 파일을 실행하는 `Process Virtual Machine`이다.\n\n<br/>\n\n---\n\n# JVM의 구성요소\n\n&ensp;컴파일 이후 JVM이 Java Application을 실행하는 큰 흐름은 다음과 같다.\n\n> (1) 컴파일 된 class 파일을 `Class Loader`가 `Runtime Data Area`에 로드한다. \\\n> (2) 적재한 바이트코드를 `Execution Engine`이 실행한다. \\\n> (3) 실행 도 중 Heap 영역에서 더 이상 참조되지 않는 objects 들을 `Garbage Collector` 가 정리한다.\n\n&ensp;생략된 것이 많은 매우 간략한 내용이지만, 애플리케이션이 실행된 이후 종료되기까지, \\\n`Class Loader`, `Runtime Data Area`, `Execution Engine`, `Garbage Collector` 와 같은 JVM 주요 컴포넌트들이 이런 유기적인 상호작용을 하며 동작한다. (`Garbage Collector`는 실행엔진 영역의 컴포넌트이지만, 중요도가 높아서 별도로 표기하였다.)\n\n&ensp;JVM의 핵심 컴포넌트들은 다음과 같은 구조를 이룬다.\n\n![JVM Structure Image](./jvm-structure.001.jpeg)\n\n&ensp;JVM을 구성하는 핵심 컴포넌트들을 정확하게 이해하는 것이 곧 JVM을 이해하는 것이라 할 수 있다. \\\n이제부터 각 컴포넌트들을 하나씩 살펴보자.\n\n<br/>\n\n---\n\n<br/>\n\n## Class Loader\n\n&ensp;클래스 로더는 컴파일 된 바이트 코드(`.class` files)들을 `Runtime Data Area` 에 로드한다. \\\n여기서 주의해야 할 것은, 모든 클래스 파일들을 이 시점에 로드하는 것이 아니라는 점이다. JVM의 기본 클래스 로딩 방식은 Lazy loading이다. `main()` 메소드가 위치한 클래스를 로드하고, 실행엔진으로 바이트 코드를 해석하며, 필요할 때 마다 각 클래스를 메인 메모리에 적재하고 읽어들인다.\n\n&ensp;클래스 로더의 세부 구성을 살펴보면 다음과 같다.\n\n![Class Loader Image](./jvm-structure.002.jpeg)\n\n&ensp;클래스 로더의 동작 메커니즘은 크게 `Loading`, `Linking`, `Initialization`  세 단계의 절차로 수행된다. \\\n각 과정들을 하나씩 살펴보자.\n\n<br/>\n\n### Loading\n&ensp;클래스 로더가 바이트 코드를 JVM에 로드하는 과정이다.`java.lang`, `java.util` 같은 Java의 스탠다드 패키지부터 라이브러리까지 각 바이트 코드마다 담당하는 클래스 로더가 다르다. 내부적으로 JVM이 `ClassLoader.loadClass()` 를 실행하여 메모리에 바이트 코드를 적재한다. \n\n&ensp;Class Loader의 세부적인 계층 구성은 다음과 같다. \n\n[Class Loader 계층 구성 이미지]\n\n- **Boostrap Class Loader** : 모든 클래스 로더의 루트 레벨로써, `rt.jar`  파일에 위치하는 Java의 스탠다드 패키지들과 `$JAVA_HOME/jre/lib` 에 있는 코어 라이브러리들을 로드한다.\n- **Extention Class Loader :** `$JAVA_HOME/jre/lib/ext` 에 위치하는 extension Java 라이브러리들을 로드한다.\n- **Application Class Loader** : `classpath` 에 위치한 클래스들을 찾아서 로드한다. 즉, 라이브러리가 아닌 개발자가 작성한 소스파일로부터 생성된 바이트 코드들을 JVM에 적재한다.\n\n&ensp;클래스 로더는 상위 로더부터 클래스를 하나씩 찾아간다. 최하단에 있는 클래스 로더까지 해당되는 클래스 파일을 찾지 못하면 `ClassNotFoundException` 예외가 발생한다. \n\n<br/>\n\n### Linking\n&ensp;`Linking`은 클래스 파일이 메모리에 적재 된 이후 의존하는 클래스 파일들을 서로 연결(Link)하고 검증하는 과정이다.\n- **Verification** : 클래스 파일의 유효성을 검증한다. 유효하지 않은 클래스 파일인 경우 `VerifyException` 이 발생한다.\n- **Preparation** : 유효성 검증을 통과한 클래스 파일들에 대하여 static 필드 및 클래스를 기본 값과 함께 초기화한다.\n- **Resolution** : Symbolic Reference 값들을 클래스, 상수, 메소드 등 Runtime Constant Pool에 있는 실제 메모리 참조 값(Actual Reference)으로 대체한다.\n\n<br/>\n\n### **Initialization**\n\n&ensp;constructor, static block 실행 등 초기화 과정이 수행된다. 클래스 로딩의 마지막 과정이라 할 수 있다. JVM은 멀티 쓰레드 환경에서 구동되기 때문에 Initialization 과정에서도 동시성 이슈가 발생할 여지가 있으므로 주의 해야한다.\n\n<br/>\n\n---\n\n<br/>\n\n## Runtime Data Area\n\n&ensp;앞서 살펴본 것과 같이 클래스 파일들은 Class Loader에 의해 Runtime Data Area에 적재 된다. Runtime Data Area는 5개 영역으로 나뉘어져 있는데, 애플리케이션 실행 도 중 데이터의 타입에 따라 `Method Area`, `Heap Area`, `Stack Area`, `PC Register`, `Native Method Stack` 영역에 저장되고 참조된다.\n\n![Runtime Data Area Image](./jvm-structure.003.jpeg)\n\n<br/>\n\n### Method Area\n\n&ensp;실행 시점에 사용되는 Constant Pool, field, method, constructors 같은 데이터들이 위치한다. 만약 가용 공간이 부족하다면 `OutOfMemorryError` 가 발생한다. JVM 당 하나의 `Method Area` 를 가진다.\n\n<br/>\n\n### Heap Area\n\n&ensp;객체 및 인스턴스 변수, 배열 등과 같은 타입의 값들이 위치한다.\n\n```java\nExample example = new Example();\n```\n\n&ensp;예를 들어 위와 같은 코드를 동작 시키면 `Example` 인스턴스를 생성한 뒤 Heap Area에 배치한다. 메소드 영역과 마찬가지로 힙 영역 역시 JVM 당 하나의 공간만을 갖게 된다.\n\n<br/>\n\n### Stack Area\n\n&ensp;특정 메소드가 호출 되고 실행되면서 사용되는 지역 변수(Local Variables), 중간 연산 결과(Operand Stack) 값이 갱신되며 저장되는 영역이다. 메소드 호출 시점마다 `Stack Frame`이라는 하나의 단위가 스택에 생성되고, 해당 메소드가 종료되는 시점에 파괴된다.\n\n&ensp;스택 영역은 JVM에 의해 쓰레드가 생성될 때 마다 각 쓰레드에 하나씩 할당된다. 따라서 동시성 문제로부터 자유롭다.\n\n<br/>\n\n### Program Counter (PC) Registers\n\n&ensp;현재 실행되고 있는 명령어의 주소 값이 저장되는 공간이다. PC Register는 현재 실행하고 있는 명령어의 실행이 끝나면 다음 명령어의 주소 값을 갱신한다. 각 쓰레드 마다 하나의 PC Register가 할당된다.\n\n<br/>\n\n### Native Method Stacks\n\n&ensp;Java가 아닌 C, C++과 같은 언어로 작성 된 메소드(Native Method) 실행을 지원하는 영역. 스택 영역과 같이 각 쓰레드마다 하나의 공간이 할당된다.\n\n<br/>\n\n---\n\n<br/>\n\n## Execution Engine\n\n![Execution Engine Image](./jvm-structure.004.jpeg)\n\n&ensp;Runtime Data Area에 각 바이트코드가 로드되면 `Execution Engine`이 이들을 실행하는데, Java compiler에 의해 생성된 클래스 파일들은 머신이 읽을 수 있는 기계어가 아닌 바이트 코드이다. 따라서 이를 한번 더 변환하는 과정이 필요하다.\n\n&ensp;JVM은 효율성을 위해 두 가지 방법을 혼합하여 이를 실현한다. 기본 전략으로는 JavaScript, Python와 같은 언어 처럼 `Interpreter`가 한 라인씩 바이트 코드를 해석하는 방식을 사용하고, 만약 반복되는 바이트 코드가 발견되면 `JIT Compiler` 를 통해 이들을 한번에 변환하기도 한다.\n\n<br/>\n\n### Interpreter\n\n&ensp;바이트 코드를 한 줄씩 읽고 실행한다. 매 라인마다 이러한 동작을 반복하기 때문에, 코드 구성에 따라 통으로 컴파일하는 방식 보다 느릴 수 있다.\n\n   아래처럼 값을 누적하는 코드와 같이, 같은 메소드의 반복이 자주 등장하는 코드의 경우 이를 통으로 변환하는 것이 더 유리할 수 있다.\n\n```java\nint total = 0;\nfor(int i = 0 ; i <= 10; i++) {\n   total += i;\n}\n```\n\n<br/>\n\n### JIT Compiler\n\n&ensp;앞서 설명한 것과 같이, 반복되는 코드가 빈번한 경우, 인터프리터 방식이 성능상 비효율적일 수 있다. 실행 엔진은 `JIT Compiler` 를 통해 이를 해결한다.\nJIT Compiler의 구성요소인 `Profiler`를 통해 반복되는 코드(hotspot)를 발견하면 JIT Compiler는 이를 네이티브 머신 코드로 한번에 컴파일한다. 변환된 코드는 시스템에 의해 한번에 읽히게 되므로 성능이 향상된다.\n\n<br/>\n\n---\n\n<br/>\n\n## Garbage Collector\n\n![Garbage Collector Image](./jvm-structure.005.jpeg)\n\n&ensp;`Garbage Collector` 는 Heap Area에 로드 되었지만 현재는 참조 되고 있지 않는 오브젝트들을 찾아서 지우고 사용되지 않는 메모리 공간을 다시 회수한다.\n\n   이는 다음의 두 과정을 거친다.\n1. **Mark** : GC가 참조되지 않는 오브젝트들을 찾아서 mark한다.\n2. **Sweep** : GC가 mark 된 오브젝트들을 힙 메모리로부터 정리한다.\n\nGC는 JVM에 의해 텀을 두고 자동으로 동작한다. `System.gc()` 를 통해 명시적으로 호출하는 방법도 있지만 이는 즉시 동작을 보장하진 않는다. 또한 JVM은 GC를 수행할 때, 이를 실행하는 쓰레드 이외에는 작업을 중단(`Stop The World`)하게 되므로 명시적인 호출은 지양해야 한다.\n\n(GC는 그 자체로 다루어야 할 주제가 굉장히 많다고 생각한다. 추후 별도의 학습 포스트로 다뤄 볼 예정이므로, 이번 포스트에서는 \n대표적인 몇 가지 GC만 가볍게 살펴보고 넘어가려 한다.)\n\n<br/>\n\n### Serial GC\n\n&ensp;싱글 쓰레드 환경의 작은 애플리케이션에서 동작하는 가장 단순한 방식의 GC 구현체이다. 싱글 쓰레드 환경에만 적합한 GC이기 때문에 GC가 동작할 때 애플리케이션 전체가 중지(`Stop The World`) 된다.\n\n<br/>\n\n### Parallel GC\n\n&ensp;JVM의 Java 8의 default GC 구현체이며, 다중 쓰레드 환경을 지원한다. `Serial GC` 보다 빠른 퍼포먼스를 보여준다.\n\n<br/>\n\n### Garbage First GC (G1 GC)\n\n&ensp;멀티 프로세스 환경을 지원하기 위해 개발 된 GC 구현체이며, 대용량 메모리 운용이 가능하다. `Stop The World` 시간을 최소화 하였지만, 이를 완전 해결하지는 못했다. Java 9부터 default GC 구현체이다.\n\n<br/>\n\n---\n\n<br/>\n\n## Java Native Interface (JNI)\n\n&ensp;앞서 `Runtime Data Area`의 `Native Method Stacks`를 다루며 `Native Code`에 대해 간단히 언급했었다.\n  JNI 역시 Java가 아닌 네이티브 코드를 사용하여 OS 혹은 하드웨어를 컨트롤하는 소프트웨어 또는 라이브러리의 사용을 가능하게 한다.\n\n<br/>\n\n---\n\n<br/>\n<br/>\n<br/>\n\n### References:\n[https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html](https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html)\n[https://en.wikipedia.org/wiki/Java_virtual_machine](https://en.wikipedia.org/wiki/Java_virtual_machine)\n[https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/](https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/)\n[https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor](https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor)\n[https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine](https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine)","excerpt":"JVM(Java Virtual Machine)은 피지컬 머신에서 자바 코드를 컴파일하고 실행하기 위한 필수 요소라 할 수 있다.\n초기의 JVM은 Java 플랫폼만을 지원하도록 설계 되었지만, 현재는 Kotlin, Groovy, Scala와 같은 다양…","fields":{"slug":"/jvm-basics/"},"frontmatter":{"date":"Apr 10, 2022","title":"JVM의 구조","tags":["JVM","GC"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n시기를 놓쳐 조금 많이 늦은 감이 있지만 2021년을 돌아보며 간단한 회고를 작성해보려 한다.\n\n작년 한해를 크게 두 조각으로 나누어 생각해보면,\n\n‘신입 개발자로 취업할만한 역량’ 을 쌓기 위해 공부와 프로젝트를 병행했던 상반기, 본격적으로 구직활동을 시작하고 취업에 도전했던 하반기로 나누어볼 수 있을 듯 하다.\n\n이 시기에 개발자를 준비하며 경험했던 것들, 마주했던 작은 고민들을 짧게나마 글로 정리해보고자 한다.\n\n# 상반기 (1월 ~ 6월)\n\n## 지금의 내가 취업만 성공하면 개발자라 할 수 있을까\n\n코드스쿼드를 수료 하고나서도 스스로에 대한 의구심을 떨쳐낼 수 없었다. 과정 중에 동료들과 함께 많은 것들을 배우고 성장했지만 신입 개발자로 취업하기에는 턱 없이 부족하다는 생각이 들었다.\n\n이미 어느 정도는 실력을 갖추고 과정에 임했던 코드스쿼드 동료들과는 달리, 나는 개발 지식과 경험이 거의 전무한 상태에서 과제와 테스트를 운좋게 통과해 과정을 시작 할 수 있었던 것 같다. 이런 나의 부족한 실력 때문에 과정이 버겁게 느껴질 때가 종종 있었다. 그럼에도 좋은 분들과 함께 했기 때문에 포기하지 않고 과정을 무사히 마칠 수 있었고, 우여곡절 끝에 수료를 할 수 있었다. (부트캠프로 코드스쿼드를 선택했던 것은 참 잘한 선택이었다고 생각한다.)\n\n코드스쿼드 과정 종료 이후 주위에서는 하나둘 씩 좋은 기업에 취업을 했는데, 나는 준비가 더 필요하다 판단하여 아예 취업 문을 두드리지 않았다. (비록 신입이어도) 개발자가 되기에는 스스로가 너무 부족하다 여겨졌다.\n\n과정 중 학습했던 것들을 정리하며 부족한 자바 스프링, 기본적인 CS 지식들을 채우는 시간을 계속 가졌다.\n\n학습과는 별개로 토이 프로젝트도 병행을 하였고, 프론트, 서버, 배포까지 온전히 혼자 진행하는 프로젝트를 진행했다. 돌아보면 공부와 시너지를 내면서 부족한 것들을 많이 채울 수 있었던 의미있는 프로젝트였다. 같이 공부했던 (당시 이미 현업 개발자가 된) 코드스쿼드 동료들에게도 코드리뷰를 부탁 했었는데, 꼼꼼하게 리뷰를 해주셔서 많은 도움을 받을 수 있었다.\n\n## 루비콘 멘토링 프로젝트\n\n혼자 진행하던 토이 프로젝트를 마칠 무렵, 루비콘 프로젝트 3기 멘티 모집 공고를 접하게 됐다.\n\n유니콘 기업에 재직중인 개발자, 디자이너 분들께 3개월동안 사이드 프로젝트 멘토링을 받으며 제품을 릴리즈 해보는 과정이었는데, 나에게 많은 도움이 될 수 있을거란 판단하에 지원을 결심했다. 모집대상이 현재 재직중인 1~3년차 주니어라 큰 기대는 갖지 않고 지원을 했는데, 운 좋게도 추가 선발되어 팀에 합류할 수 있었다.\n\n그렇게 프론트엔드 엔지니어, 백엔드 엔지니어, 디자이너 각 포지션별로 1명씩 멘티 3명, 그리고 멘토 한 분까지 총 네명이 한팀이 되어 프로젝트를 진행하게 됐다. (돌아보면 짧은 기간동안 상당히 많은 것들을 해야했던 빡빡한 프로젝트 일정이었는데, 상세히 기술하자면 하나의 포스트를 따로 작성 해야할 것 같다.)\n\n프로젝트를 진행하며 기술적인 하드 스킬 뿐만 아니라 업계를 리드하는 기업들의 성숙한 커뮤니케이션 문화를 간접 경험할 수 있었고, 소프트 스킬에 대한 많은 고민 해볼 수 있었다. 그리고 다른 무엇보다 이 기간동안 개발자라는 롤에 대한 본질적인 고찰을 해볼 수 있었던 시간이라는 것이 가장 뜻 깊었다.\n\n토이 프로젝트라는 특성상 엔지니어, 기획자라는 자신의 특정 포지션에만 집중하기가 힘들다. 엔지니어 역할에만 나 자신을 한정하는 것이 아니라 개발자라는 롤을 벗어나 공동의 문제 해결 그 자체를 목표로 협업을 해봄으로써, 개발자의 근본적인 존재 이유에 대한 깊은 고민을 해볼 수 있었다. 또한 너무나 훌륭한 멘토분을 만나서 많은 자극을 받았다. 하드스킬 뿐만 아니라 개발자로서 갖춰야 할 좋은 애티튜드를 곁에서 많이 보고 배울 수 있었다.\n\n다만 아쉬웠던 것은 중간에 바디 컨디션 급하락과 개인적인 번아웃으로인해 더 큰 아웃풋을 만들어내지 못했던 점이다. 멘토님과 중간중간 원온원을 하면서 어려운 점을 토로했었는데 그때마다 아낌없는 조언을 해주셔서 멘탈을 잡으며 완주할 수 있었던 것 같다.\n\n좋은 팀원 분들을 만났고, 멘토링 기간이 끝나고도 프로젝트를 지속하며 고도화 할 수 있었으나 개인적인 번아웃 때문에 더 이상 함께하지 않기로 결정했었다. 돌아보면 아쉽기도 하지만 이 때는 번아웃 극복이 너무 힘들었던 것 같다. 짧다면 짧은 기간동안 정말 많은 것들을 경험했던 것 같다.\n\n2021년 가장 잘했던 일을 하나만 뽑으라면 주저 없이 루비콘 멘토링 프로젝트를 지원 했던 것이라 할 수 있을 것 같다.\n\n# 하반기 (7월 ~ )\n\n## 구직활동\n\n루비콘 멘토링 프로젝트 이후 2주정도 휴식기를 가졌다. 개발자를 준비하며 처음 번아웃을 겪었던 시기였는데 이게 제법 심하게 왔다.\n\n그토록 재밌던 개발과 코드에 대한 고민들이 모두 성가신 일로 느껴졌고 IDE를 켜는 것이 점점 싫어졌다. 단 며칠 사이 특정 시점 이후 급격한 감정 전환을 느낀 신기한 경험이었다.\n\n처음에는 이게 번아웃인지도 잘 몰랐는데 주변에 고민을 털어놓다 알게 되었다. 쉬면 괜찮아질거라는 생각으로 한동안 개발 관련 된 모든 것들을 다 내려 놓고 쉬었다. 2주정도 지나니 회복 됐던 것 같다. 페이스를 회복한 뒤에는 본격적인 구직 활동을 시작하게 되었다.\n\n먼저 스타트업 위주로 원티드, 로켓펀치에서 지원 할만한 기업을 리스트업 해보았다. 기대보다 많지는 않았다.\n\n경력이 없다보니 두 개의 사이드 프로젝트와 루비콘 멘토링 프로젝트 같은 활동 이외에는 이력서에 어필할 수 있는 것들이 거의 없다시피 했다. 이력서를 넣어서 지원해보면 패스하는 비율에 비해 탈락률이 월등히 높았다. 줄줄히 서류 탈락하는 모습을 보며 멘탈 잡기가 쉽지는 않았는데, 어쩌다 면접 기회가 주어지면 최선을 다해 임했다. 이력서와 반대로 면접 합격률은 생각보다 높았다.\n\n최종 합격을 했지만 여러 이유로 가지 않은 곳이 몇 곳 있었다. 그 중 특히 면접 경험이 좋아서 가고 싶었던 한 회사가 정말 많이 아쉬웠다.\n히스토리를 자세히 설명할 수는 없지만 처우에 관한 것 때문에 고심 끝에 포기 했었는데, 굉장히 많이 아쉽고 허무하기까지 했다.\n한동안은 잘못된 선택을 한 것은 아닐까 계속 미련이 남아있었다.\n\n본격적인 구직 활동을 처음 시작하고 받았던 첫 인상은 ‘신입 백엔드 개발자'를 원하는 회사가 그리 많지 않다는 것이었다.\n\n## 우아한형제들, 탈락\n\n우아한형제들 개발자 채용에 지원할 수 있는 기회가 생겨 서류와 코딩 테스트를 통과하고 면접을 보게 됐다.\n\n면접 전까지는 덤덤하다가 당일에 굉장히 많이 긴장했던 기억이 난다. 아는 내용은 자세히 설명드리려 노력했고, 모르는 것들 앞에서는 최대한 솔직하려했다. 면접에 관한 자세한 내용을 설명할 수 없지만, 굉장히 의미있고 좋은 경험이었다.\n알고있다고 생각 했던 것들이 실상은 모두 죽은 지식이었다는 것, 현재의 나에 대한 자기 객관화와 반성을 할 수 있었다.\n결과는 아쉽게 됐지만 훗 날 꼭 다시 도전 해보고 싶다.\n\n## 취업\n\n우아한형제들 채용 프로세스가 진행되고 있던 무렵, 만약 탈락을 하게되면 이제는 더이상 미루지 말고 결정을 해야겠다고 마음을 먹었다.\n언제 올지 모르는, 오더라도 잡을 수 있을 지 모르는 기회를 마냥 계속 기다리기 보다는. 서비스 회사라면 우선 시작해서 개발자로 현업을 경험 해보는게 나에게 더 이로울 것이라 판단했다.\n아쉬움이 없지는 않았지만, 그 무렵 시기가 잘 맞았던 곳에서 신입 개발자로 첫 시작을 하게 되었다.\n\n# 2022\n\n작년 말부터 좋은 시니어분들께서 개발팀에 많이 합류하였다.\n\n업무를 통해 주어지는 문제를 함께 고민하고, 그 과정에서 많은 것들을 배우고 있다. 매 순간 부족함을 느낄 때가 많아 업무 외에도 개인 시간을 허투루 쓰지 않고 계속 발전하고자 하는 노력을 놓지 않으려 한다.\n\n시작이 반이라고 한다. 시작이 정말로 반씩이나 되는지는 잘 모르겠지만 수 많은 고민들과 선택이 필요했고 시작을 하기가 쉽지만은 않았던 것 같다. 이제 시작은 했으니 앞으로 부족한 것들은 하나씩 채워나가면 될 것 같다. 개발자로서의 역량뿐만 아니라 개인적으로 여러 아쉬운 점들을 하나씩 메워가고자 한다.\n\n올해도 꾸준함의 힘을 믿고 놓지말고 해보자.\n\n-끗-\n","excerpt":"시기를 놓쳐 조금 많이 늦은 감이 있지만 2021년을 돌아보며 간단한 회고를 작성해보려 한다. 작년 한해를 크게 두 조각으로 나누어 생각해보면, ‘신입 개발자로 취업할만한 역량’ 을 쌓기 위해 공부와 프로젝트를 병행했던 상반기, 본격적으로 구직활동을…","fields":{"slug":"/retrospect2021/"},"frontmatter":{"date":"Mar 14, 2022","title":"2021년 회고","tags":["회고"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n학습, 개발 과정에서 코드로 구현 했던 것들을 정리하고 기록합니다.\n\n지식의 공유보다는 기록과 정리의 목적이 크기 때문에 정제되지 않은 내용이 다소 있을 수 있습니다.  \n포스트에서 잘못 된 내용을 발견 하신다면 무엇이든 코멘트를 통해 공유 해주세요.\n\n부족한 지식을 완성하는데에 큰 도움이 됩니다 :)\n","excerpt":"학습, 개발 과정에서 코드로 구현 했던 것들을 정리하고 기록합니다. 지식의 공유보다는 기록과 정리의 목적이 크기 때문에 정제되지 않은 내용이 다소 있을 수 있습니다. 포스트에서 잘못 된 내용을 발견 하신다면 무엇이든 코멘트를 통해 공유 해주세요. 부…","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Aug 15, 2021","title":"About","tags":["About"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}